## API Report File for "@devtools/backend-plugin-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { AuthorizePermissionRequest } from '@devtools/plugin-permission-common';
import { AuthorizePermissionResponse } from '@devtools/plugin-permission-common';
import { Config } from '@devtools/config';
import { Duration } from 'luxon';
import { EvaluatorRequestOptions } from '@devtools/plugin-permission-common';
import type { Handler } from 'express';
import { HumanDuration } from '@devtools/types';
import { isChildPath } from '@devtools/cli-common';
import { JsonObject } from '@devtools/types';
import { JsonValue } from '@devtools/types';
import { Knex } from 'knex';
import { PermissionAttributes } from '@devtools/plugin-permission-common';
import { PermissionEvaluator } from '@devtools/plugin-permission-common';
import { QueryPermissionRequest } from '@devtools/plugin-permission-common';
import { QueryPermissionResponse } from '@devtools/plugin-permission-common';
import { Readable } from 'stream';
import type { Request as Request_2 } from 'express';
import type { Response as Response_2 } from 'express';

// @public
export interface AuthService {
  authenticate(
    token: string,
    options?: {
      allowLimitedAccess?: boolean;
    },
  ): Promise<DevtoolsCredentials>;
  getLimitedUserToken(
    credentials: DevtoolsCredentials<DevtoolsUserPrincipal>,
  ): Promise<{
    token: string;
    expiresAt: Date;
  }>;
  getNoneCredentials(): Promise<DevtoolsCredentials<DevtoolsNonePrincipal>>;
  getOwnServiceCredentials(): Promise<
    DevtoolsCredentials<DevtoolsServicePrincipal>
  >;
  getPluginRequestToken(options: {
    onBehalfOf: DevtoolsCredentials;
    targetPluginId: string;
  }): Promise<{
    token: string;
  }>;
  isPrincipal<TType extends keyof DevtoolsPrincipalTypes>(
    credentials: DevtoolsCredentials,
    type: TType,
  ): credentials is DevtoolsCredentials<DevtoolsPrincipalTypes[TType]>;
  listPublicServiceKeys(): Promise<{
    keys: JsonObject[];
  }>;
}

// @public (undocumented)
export interface BackendFeature {
  // (undocumented)
  $$type: '@devtools/BackendFeature';
}

// @public
export interface BackendModuleRegistrationPoints {
  // (undocumented)
  registerExtensionPoint<TExtensionPoint>(
    ref: ExtensionPoint<TExtensionPoint>,
    impl: TExtensionPoint,
  ): void;
  // (undocumented)
  registerInit<
    TDeps extends {
      [name in string]: ServiceRef<unknown> | ExtensionPoint<unknown>;
    },
  >(options: {
    deps: TDeps;
    init(deps: DepsToInstances<TDeps>): Promise<void>;
  }): void;
}

// @public
export interface BackendPluginRegistrationPoints {
  // (undocumented)
  registerExtensionPoint<TExtensionPoint>(
    ref: ExtensionPoint<TExtensionPoint>,
    impl: TExtensionPoint,
  ): void;
  // (undocumented)
  registerInit<
    TDeps extends {
      [name in string]: ServiceRef<unknown>;
    },
  >(options: {
    deps: TDeps;
    init(deps: DepsToInstances<TDeps>): Promise<void>;
  }): void;
}

// @public
export type DevtoolsCredentials<TPrincipal = unknown> = {
  $$type: '@devtools/DevtoolsCredentials';
  expiresAt?: Date;
  principal: TPrincipal;
};

// @public
export type DevtoolsNonePrincipal = {
  type: 'none';
};

// @public
export type DevtoolsPrincipalAccessRestrictions = {
  permissionNames?: string[];
  permissionAttributes?: {
    action?: Array<Required<PermissionAttributes>['action']>;
  };
};

// @public
export type DevtoolsPrincipalTypes = {
  user: DevtoolsUserPrincipal;
  service: DevtoolsServicePrincipal;
  none: DevtoolsNonePrincipal;
  unknown: unknown;
};

// @public
export type DevtoolsServicePrincipal = {
  type: 'service';
  subject: string;
  accessRestrictions?: DevtoolsPrincipalAccessRestrictions;
};

// @public
export interface DevtoolsUserInfo {
  // (undocumented)
  ownershipEntityRefs: string[];
  // (undocumented)
  userEntityRef: string;
}

// @public
export type DevtoolsUserPrincipal = {
  type: 'user';
  userEntityRef: string;
};

// @public
export interface CacheService {
  delete(key: string): Promise<void>;
  get<TValue extends JsonValue>(key: string): Promise<TValue | undefined>;
  set(
    key: string,
    value: JsonValue,
    options?: CacheServiceSetOptions,
  ): Promise<void>;
  withOptions(options: CacheServiceOptions): CacheService;
}

// @public
export type CacheServiceOptions = {
  defaultTtl?: number | HumanDuration;
};

// @public
export type CacheServiceSetOptions = {
  ttl?: number | HumanDuration;
};

// @public
export namespace coreServices {
  const auth: ServiceRef<AuthService, 'plugin', 'singleton'>;
  const userInfo: ServiceRef<UserInfoService, 'plugin', 'singleton'>;
  const cache: ServiceRef<CacheService, 'plugin', 'singleton'>;
  const rootConfig: ServiceRef<RootConfigService, 'root', 'singleton'>;
  const database: ServiceRef<DatabaseService, 'plugin', 'singleton'>;
  const discovery: ServiceRef<DiscoveryService, 'plugin', 'singleton'>;
  const rootHealth: ServiceRef<RootHealthService, 'root', 'singleton'>;
  const httpAuth: ServiceRef<HttpAuthService, 'plugin', 'singleton'>;
  const httpRouter: ServiceRef<HttpRouterService, 'plugin', 'singleton'>;
  const lifecycle: ServiceRef<LifecycleService, 'plugin', 'singleton'>;
  const logger: ServiceRef<LoggerService, 'plugin', 'singleton'>;
  const permissions: ServiceRef<PermissionsService, 'plugin', 'singleton'>;
  const pluginMetadata: ServiceRef<
    PluginMetadataService,
    'plugin',
    'singleton'
  >;
  const rootHttpRouter: ServiceRef<RootHttpRouterService, 'root', 'singleton'>;
  const rootLifecycle: ServiceRef<RootLifecycleService, 'root', 'singleton'>;
  const rootLogger: ServiceRef<RootLoggerService, 'root', 'singleton'>;
  const scheduler: ServiceRef<SchedulerService, 'plugin', 'singleton'>;
  const urlReader: ServiceRef<UrlReaderService, 'plugin', 'singleton'>;
}

// @public
export function createBackendFeatureLoader<
  TDeps extends {
    [name in string]: unknown;
  },
>(options: CreateBackendFeatureLoaderOptions<TDeps>): BackendFeature;

// @public
export interface CreateBackendFeatureLoaderOptions<
  TDeps extends {
    [name in string]: unknown;
  },
> {
  // (undocumented)
  deps?: {
    [name in keyof TDeps]: ServiceRef<TDeps[name], 'root'>;
  };
  // (undocumented)
  loader(deps: TDeps):
    | Iterable<
        | BackendFeature
        | Promise<{
            default: BackendFeature;
          }>
      >
    | Promise<
        Iterable<
          | BackendFeature
          | Promise<{
              default: BackendFeature;
            }>
        >
      >
    | AsyncIterable<
        | BackendFeature
        | {
            default: BackendFeature;
          }
      >;
}

// @public
export function createBackendModule(
  options: CreateBackendModuleOptions,
): BackendFeature;

// @public
export interface CreateBackendModuleOptions {
  moduleId: string;
  pluginId: string;
  // (undocumented)
  register(reg: BackendModuleRegistrationPoints): void;
}

// @public
export function createBackendPlugin(
  options: CreateBackendPluginOptions,
): BackendFeature;

// @public
export interface CreateBackendPluginOptions {
  pluginId: string;
  // (undocumented)
  register(reg: BackendPluginRegistrationPoints): void;
}

// @public
export function createExtensionPoint<T>(
  options: CreateExtensionPointOptions,
): ExtensionPoint<T>;

// @public
export interface CreateExtensionPointOptions {
  id: string;
}

// @public
export function createServiceFactory<
  TService,
  TInstances extends 'singleton' | 'multiton',
  TImpl extends TService,
  TDeps extends {
    [name in string]: ServiceRef<unknown, 'root'>;
  },
>(
  options: RootServiceFactoryOptions<TService, TInstances, TImpl, TDeps>,
): ServiceFactory<TService, 'root', TInstances>;

// @public
export function createServiceFactory<
  TService,
  TInstances extends 'singleton' | 'multiton',
  TImpl extends TService,
  TDeps extends {
    [name in string]: ServiceRef<unknown>;
  },
  TContext = undefined,
>(
  options: PluginServiceFactoryOptions<
    TService,
    TInstances,
    TContext,
    TImpl,
    TDeps
  >,
): ServiceFactory<TService, 'plugin', TInstances>;

// @public
export function createServiceRef<TService>(
  options: ServiceRefOptions<TService, 'plugin', 'singleton'>,
): ServiceRef<TService, 'plugin', 'singleton'>;

// @public
export function createServiceRef<TService>(
  options: ServiceRefOptions<TService, 'root', 'singleton'>,
): ServiceRef<TService, 'root', 'singleton'>;

// @public
export function createServiceRef<TService>(
  options: ServiceRefOptions<TService, 'plugin', 'multiton'>,
): ServiceRef<TService, 'plugin', 'multiton'>;

// @public
export function createServiceRef<TService>(
  options: ServiceRefOptions<TService, 'root', 'multiton'>,
): ServiceRef<TService, 'root', 'multiton'>;

// @public
export interface DatabaseService {
  getClient(): Promise<Knex>;
  migrations?: {
    skip?: boolean;
  };
}

// @public
export interface DiscoveryService {
  getBaseUrl(pluginId: string): Promise<string>;
  getExternalBaseUrl(pluginId: string): Promise<string>;
}

// @public
export type ExtensionPoint<T> = {
  id: string;
  T: T;
  toString(): string;
  $$type: '@devtools/ExtensionPoint';
};

// @public
export interface HttpAuthService {
  credentials<TAllowed extends keyof DevtoolsPrincipalTypes = 'unknown'>(
    req: Request_2<any, any, any, any, any>,
    options?: {
      allow?: Array<TAllowed>;
      allowLimitedAccess?: boolean;
    },
  ): Promise<DevtoolsCredentials<DevtoolsPrincipalTypes[TAllowed]>>;
  issueUserCookie(
    res: Response_2,
    options?: {
      credentials?: DevtoolsCredentials;
    },
  ): Promise<{
    expiresAt: Date;
  }>;
}

// @public
export interface HttpRouterService {
  addAuthPolicy(policy: HttpRouterServiceAuthPolicy): void;
  use(handler: Handler): void;
}

// @public
export interface HttpRouterServiceAuthPolicy {
  // (undocumented)
  allow: 'unauthenticated' | 'user-cookie';
  // (undocumented)
  path: string;
}

export { isChildPath };

// @public
export function isDatabaseConflictError(e: unknown): boolean;

// @public
export interface LifecycleService {
  addShutdownHook(
    hook: LifecycleServiceShutdownHook,
    options?: LifecycleServiceShutdownOptions,
  ): void;
  addStartupHook(
    hook: LifecycleServiceStartupHook,
    options?: LifecycleServiceStartupOptions,
  ): void;
}

// @public (undocumented)
export type LifecycleServiceShutdownHook = () => void | Promise<void>;

// @public (undocumented)
export interface LifecycleServiceShutdownOptions {
  logger?: LoggerService;
}

// @public (undocumented)
export type LifecycleServiceStartupHook = () => void | Promise<void>;

// @public (undocumented)
export interface LifecycleServiceStartupOptions {
  logger?: LoggerService;
}

// @public
export interface LoggerService {
  // (undocumented)
  child(meta: JsonObject): LoggerService;
  // (undocumented)
  debug(message: string, meta?: Error | JsonObject): void;
  // (undocumented)
  error(message: string, meta?: Error | JsonObject): void;
  // (undocumented)
  info(message: string, meta?: Error | JsonObject): void;
  // (undocumented)
  warn(message: string, meta?: Error | JsonObject): void;
}

// @public
export interface PermissionsService extends PermissionEvaluator {
  authorize(
    requests: AuthorizePermissionRequest[],
    options: PermissionsServiceRequestOptions,
  ): Promise<AuthorizePermissionResponse[]>;
  authorizeConditional(
    requests: QueryPermissionRequest[],
    options: PermissionsServiceRequestOptions,
  ): Promise<QueryPermissionResponse[]>;
}

// @public
export interface PermissionsServiceRequestOptions
  extends EvaluatorRequestOptions {
  // (undocumented)
  credentials: DevtoolsCredentials;
}

// @public
export interface PluginMetadataService {
  getId(): string;
}

// @public (undocumented)
export interface PluginServiceFactoryOptions<
  TService,
  TInstances extends 'singleton' | 'multiton',
  TContext,
  TImpl extends TService,
  TDeps extends {
    [name in string]: ServiceRef<unknown>;
  },
> {
  // (undocumented)
  createRootContext?(
    deps: ServiceRefsToInstances<TDeps, 'root'>,
  ): TContext | Promise<TContext>;
  // (undocumented)
  deps: TDeps;
  // (undocumented)
  factory(
    deps: ServiceRefsToInstances<TDeps>,
    context: TContext,
  ): TImpl | Promise<TImpl>;
  initialization?: 'always' | 'lazy';
  // (undocumented)
  service: ServiceRef<TService, 'plugin', TInstances>;
}

// @public
export function readSchedulerServiceTaskScheduleDefinitionFromConfig(
  config: Config,
): SchedulerServiceTaskScheduleDefinition;

// @public
export function resolvePackagePath(name: string, ...paths: string[]): string;

// @public
export function resolveSafeChildPath(base: string, path: string): string;

// @public
export interface RootConfigService extends Config {}

// @public (undocumented)
export interface RootHealthService {
  getLiveness(): Promise<{
    status: number;
    payload?: JsonValue;
  }>;
  getReadiness(): Promise<{
    status: number;
    payload?: JsonValue;
  }>;
}

// @public
export interface RootHttpRouterService {
  use(path: string, handler: Handler): void;
}

// @public
export interface RootLifecycleService extends LifecycleService {
  // (undocumented)
  addBeforeShutdownHook(hook: () => void | Promise<void>): void;
}

// @public
export interface RootLoggerService extends LoggerService {}

// @public (undocumented)
export interface RootServiceFactoryOptions<
  TService,
  TInstances extends 'singleton' | 'multiton',
  TImpl extends TService,
  TDeps extends {
    [name in string]: ServiceRef<unknown>;
  },
> {
  // (undocumented)
  deps: TDeps;
  // (undocumented)
  factory(deps: ServiceRefsToInstances<TDeps, 'root'>): TImpl | Promise<TImpl>;
  initialization?: 'always' | 'lazy';
  // (undocumented)
  service: ServiceRef<TService, 'root', TInstances>;
}

// @public
export interface SchedulerService {
  createScheduledTaskRunner(
    schedule: SchedulerServiceTaskScheduleDefinition,
  ): SchedulerServiceTaskRunner;
  getScheduledTasks(): Promise<SchedulerServiceTaskDescriptor[]>;
  scheduleTask(
    task: SchedulerServiceTaskScheduleDefinition &
      SchedulerServiceTaskInvocationDefinition,
  ): Promise<void>;
  triggerTask(id: string): Promise<void>;
}

// @public
export type SchedulerServiceTaskDescriptor = {
  id: string;
  scope: 'global' | 'local';
  settings: {
    version: number;
  } & JsonObject;
};

// @public
export type SchedulerServiceTaskFunction =
  | ((abortSignal: AbortSignal) => void | Promise<void>)
  | (() => void | Promise<void>);

// @public
export interface SchedulerServiceTaskInvocationDefinition {
  fn: SchedulerServiceTaskFunction;
  id: string;
  signal?: AbortSignal;
}

// @public
export interface SchedulerServiceTaskRunner {
  run(task: SchedulerServiceTaskInvocationDefinition): Promise<void>;
}

// @public
export interface SchedulerServiceTaskScheduleDefinition {
  frequency:
    | {
        cron: string;
      }
    | Duration
    | HumanDuration
    | {
        trigger: 'manual';
      };
  initialDelay?: Duration | HumanDuration;
  scope?: 'global' | 'local';
  timeout: Duration | HumanDuration;
}

// @public
export interface SchedulerServiceTaskScheduleDefinitionConfig {
  frequency:
    | {
        cron: string;
      }
    | string
    | HumanDuration
    /**
     * This task will only run when manually triggered with the `triggerTask` method; no automatic
     * scheduling. This is useful for locking of global tasks that should not be run concurrently.
     */
    | {
        trigger: 'manual';
      };
  initialDelay?: string | HumanDuration;
  scope?: 'global' | 'local';
  timeout: string | HumanDuration;
}

// @public (undocumented)
export interface ServiceFactory<
  TService = unknown,
  TScope extends 'plugin' | 'root' = 'plugin' | 'root',
  TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton',
> extends BackendFeature {
  // (undocumented)
  service: ServiceRef<TService, TScope, TInstances>;
}

// @public
export type ServiceRef<
  TService,
  TScope extends 'root' | 'plugin' = 'root' | 'plugin',
  TInstances extends 'singleton' | 'multiton' = 'singleton' | 'multiton',
> = {
  id: string;
  scope: TScope;
  multiton?: TInstances extends 'multiton' ? true : false;
  T: TService;
  $$type: '@devtools/ServiceRef';
};

// @public (undocumented)
export interface ServiceRefOptions<
  TService,
  TScope extends 'root' | 'plugin',
  TInstances extends 'singleton' | 'multiton',
> {
  // (undocumented)
  defaultFactory?(
    service: ServiceRef<TService, TScope>,
  ): Promise<ServiceFactory>;
  // (undocumented)
  id: string;
  // (undocumented)
  multiton?: TInstances extends 'multiton' ? true : false;
  // (undocumented)
  scope?: TScope;
}

// @public
export interface UrlReaderService {
  readTree(
    url: string,
    options?: UrlReaderServiceReadTreeOptions,
  ): Promise<UrlReaderServiceReadTreeResponse>;
  readUrl(
    url: string,
    options?: UrlReaderServiceReadUrlOptions,
  ): Promise<UrlReaderServiceReadUrlResponse>;
  search(
    url: string,
    options?: UrlReaderServiceSearchOptions,
  ): Promise<UrlReaderServiceSearchResponse>;
}

// @public
export type UrlReaderServiceReadTreeOptions = {
  filter?(
    path: string,
    info?: {
      size: number;
    },
  ): boolean;
  etag?: string;
  signal?: AbortSignal;
  token?: string;
};

// @public
export type UrlReaderServiceReadTreeResponse = {
  files(): Promise<UrlReaderServiceReadTreeResponseFile[]>;
  archive(): Promise<NodeJS.ReadableStream>;
  dir(options?: UrlReaderServiceReadTreeResponseDirOptions): Promise<string>;
  etag: string;
};

// @public
export type UrlReaderServiceReadTreeResponseDirOptions = {
  targetDir?: string;
};

// @public
export type UrlReaderServiceReadTreeResponseFile = {
  path: string;
  content(): Promise<Buffer>;
  lastModifiedAt?: Date;
};

// @public
export type UrlReaderServiceReadUrlOptions = {
  etag?: string;
  lastModifiedAfter?: Date;
  signal?: AbortSignal;
  token?: string;
};

// @public
export type UrlReaderServiceReadUrlResponse = {
  buffer(): Promise<Buffer>;
  stream?(): Readable;
  etag?: string;
  lastModifiedAt?: Date;
};

// @public
export type UrlReaderServiceSearchOptions = {
  etag?: string;
  signal?: AbortSignal;
  token?: string;
};

// @public
export type UrlReaderServiceSearchResponse = {
  files: UrlReaderServiceSearchResponseFile[];
  etag: string;
};

// @public
export type UrlReaderServiceSearchResponseFile = {
  url: string;
  content(): Promise<Buffer>;
  lastModifiedAt?: Date;
};

// @public
export interface UserInfoService {
  getUserInfo(credentials: DevtoolsCredentials): Promise<DevtoolsUserInfo>;
}
```
